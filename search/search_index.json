{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "TiLearn homepage", "text": "TiLearn | Optimize Your Time with AI <p>     Welcome to our open-source project dedicated to time management and scheduling solutions. This platform is designed to empower individuals and teams to optimize their daily routines, enhance productivity, and achieve their goals more efficiently. By providing a range of tools and resources, we aim to foster a community-driven approach to managing time and tasks effectively. Whether you're a student, a professional, or simply looking to make the most of your day, our project offers innovative strategies and customizable schedules to help you stay on track. Join us in building a future where time management is accessible to everyone.   </p> <p>     Join us in creating a community where time management tools and effective scheduling practices are accessible to all.   </p> GitHub repository <p>Explore the code, contribute, or check out in our GitHub repository:</p>                            GitHub                        PyPI package <p>Easily install and use TiLearn by accessing our package on PyPI:</p>                            PyPI                        <p>(TiLearn 0.0.10 released!)</p> Web mapping <ol> <li> Getting started <p>This document provides an overview of project content and the generalization of the various problems it addresses.</p> </li> <li> User Guide <p>This document categorizes all the problems, detailing their foundational concepts, relevant materials, and solutions.</p> </li> <li> API reference <p>This section details API endpoints, usage, parameters, and responses for effective integration.</p> </li> </ol> <p>For any questions, suggestions, or collaborations, feel free to reach out to me.  I'm excited to connect with fellow enthusiasts and contributors!</p>"}, {"location": "about/", "title": "About us", "text": ""}, {"location": "api-reference/", "title": "TiLearn reference", "text": "<p>Info</p> <ul> <li>Release: 0.0.12</li> <li>Date: August 27, 2024</li> </ul> <p>This reference manual offers an extensive overview of the functions, modules, and objects available in TiLearn. Each section thoroughly explains the components, including their definitions, functionalities, and practical applications within the library.</p> <p>By exploring this manual, users can gain a clear understanding of how to utilize these elements effectively in their projects. For a more in-depth exploration of the underlying concepts and advanced usage examples, please refer to the full tutorial.</p>"}, {"location": "api-reference/#python-api", "title": "Python API", "text": "<ul> <li>The Total (Weighted) Completion Time<ul> <li>Independence jobs (<code>show_mytime</code>)</li> </ul> </li> </ul>"}, {"location": "api-reference/#acknowledgements", "title": "Acknowledgements", "text": "<p>Significant portions of this manual are based on foundational texts in the field, including \"Single Machine Scheduling\" by Le Minh Huy and \"Scheduling: Theory, Algorithms, and Systems\" by Michael Pinedo. These sources provide the theoretical background and algorithms that underpin many of the scheduling concepts presented here.</p> <p>The reference documentation within this manual, detailing the various functions, modules, and objects available in TiLearn, has been meticulously developed by the contributors and developers of TiLearn. Each entry has been carefully written to provide comprehensive explanations, practical examples, and insights into how to effectively utilize these components within scheduling and optimization projects. For more advanced topics and extended examples, users are encouraged to consult the full references.</p>"}, {"location": "api-reference/in-job/i-job/", "title": "tilearn.show_mytime", "text": "<p>Info</p> <p>For a more in-depth understanding of the concept, you can check here.</p>"}, {"location": "api-reference/in-job/i-job/#tilearnshow_mytimelist-due-date", "title": "tilearn.show_mytime(list, due date)", "text": "<ul> <li> <p>Paramenter:</p> <ul> <li> <p>list: list or an array, that holds the job table data.</p> <p>Each element in this collection should represent a job name, including relevant attributes such as job ID, quantity, release time, due date, and priority. These attributes are necessary for scheduling the jobs. See notes for a more detailed explanation of which elements in the array need to be used.</p> </li> <li> <p>due date : deadline by which all jobs in the provided list need to be completed.</p> <p>It represents a specific date and time and is crucial for scheduling purposes. The function will use this date to determine whether each job can be completed on time or if adjustments need to be made to meet this deadline. The due date should be formatted correctly to ensure accurate comparisons and calculations within the function.</p> </li> </ul> </li> </ul>"}, {"location": "api-reference/in-job/i-job/#notes", "title": "Notes", "text": "<p>The list is a key function that displays your job data.</p> <p>See the example below for more details:</p> List example. <p>Explanation:</p> Column position Meaning The first column Indicates the job name. The second column Displays the quantity required to complete each job. For example, Job 1 requires 12 units to be finished. The unit type is not crucial; it is up to your discretion and it simply serves as a value for determining how weighty the job is. (e.g. 12 minutes, 12 pages for reading,...) The third column Details the release time of each job. For example, Job 1 is released on day 0. The fourth column Specifies the due date of each job. For example, Job 1 is due on day 30. The last column Exhibits the job\u2019s weight (representing job\u2019s priority value, you can assign weight values from 1 to 3 or 1 to 10, based on your judgment). The higher the priority value, the more important it is, if all jobs have equal priority, their weights would be 1. For example, the priority of Job 1 is 2."}, {"location": "api-reference/in-job/i-job/#examples", "title": "Examples", "text": "<p>Code Implementation:</p> <p><pre><code>import tilearn as tl\n\ndata = [['Job 1', 4, 0, 10, 1], ['Job 2', 9, 0, 10, 3], ['Job 3', 6, 0, 10, 2], ['Job 4', 7, 0, 10, 3], ['Job 5', 4, 0, 10, 2], ['Job 6', 5, 0, 10, 1], ['Job 7', 8, 0, 10, 3], ['Job 8', 3, 0, 10, 1], ['Job 9', 2, 0, 10, 1], ['Job 10', 6, 0, 10, 2]]\n\nprint(tl.show_mytime(data, 10))\n</code></pre> Output: <pre><code>[['Job 5', 4, 0, 10, 2, 0.7407407407407407, 2.7], ['Job 9', 2, 0, 10, 1, 0.37037037037037035, 2.7], ['Job 4', 7, 0, 10, 3, 1.2962962962962963, 2.3142857142857145], ['Job 7', 8, 0, 10, 3, 1.4814814814814814, 2.025], ['Job 2', 9, 0, 10, 3, 1.6666666666666667, 1.7999999999999998], ['Job 3', 6, 0, 10, 2, 1.1111111111111112, 1.7999999999999998], ['Job 8', 3, 0, 10, 1, 0.5555555555555556, 1.7999999999999998], ['Job 10', 6, 0, 10, 2, 1.1111111111111112, 1.7999999999999998], ['Job 1', 4, 0, 10, 1, 0.7407407407407407, 1.35], ['Job 6', 5, 0, 10, 1, 0.9259259259259259, 1.08]]\n</code></pre></p> <p>To make the output more readable, you can adjust your code as shown below:</p> <p><pre><code>schedule = tl.show_mytime(data, 10)\n\nfor row in schedule:\n    print(row)\n</code></pre> Output: <pre><code>['Job 5', 4, 0, 10, 2, 0.7407407407407407, 2.7]\n['Job 9', 2, 0, 10, 1, 0.37037037037037035, 2.7]\n['Job 4', 7, 0, 10, 3, 1.2962962962962963, 2.3142857142857145]\n['Job 7', 8, 0, 10, 3, 1.4814814814814814, 2.025]\n['Job 2', 9, 0, 10, 3, 1.6666666666666667, 1.7999999999999998]\n['Job 3', 6, 0, 10, 2, 1.1111111111111112, 1.7999999999999998]\n['Job 8', 3, 0, 10, 1, 0.5555555555555556, 1.7999999999999998]\n['Job 10', 6, 0, 10, 2, 1.1111111111111112, 1.7999999999999998]\n['Job 1', 4, 0, 10, 1, 0.7407407407407407, 1.35]\n['Job 6', 5, 0, 10, 1, 0.9259259259259259, 1.08]\n</code></pre></p>"}, {"location": "getting-started/", "title": "TiLearn: Getting Started", "text": ""}, {"location": "getting-started/#introduction", "title": "Introduction", "text": "<p>TiLearn is a Python package designed to optimize time management and provide advanced scheduling solutions using AI. This platform is grounded in the principles of Operations Research, a critical field focused on the efficient allocation of resources and the optimization of processes. By harnessing these techniques, TiLearn empowers individuals and teams to streamline their daily routines, enhance productivity, and achieve their goals more effectively.</p> <p>At its core, TiLearn integrates the latest advancements in artificial intelligence with well-established scheduling methods to provide customized solutions. From minimizing task completion times to reducing delays, our project delivers innovative approaches that adapt to your unique requirements. Join us in shaping a future where efficient time management is accessible to everyone, helping you stay on track.</p>"}, {"location": "getting-started/#how-to-install", "title": "How to Install", "text": "<p>Before installing TiLearn, ensure you have the following:</p> <ul> <li> <p>Python: Make sure you have Python 3.10.0 or higher installed. You can check your Python version by running the following command in your terminal:</p> <pre><code>python --version\n</code></pre> <p>or </p> <pre><code>python3 --version\n</code></pre> </li> <li> <p>pip: The Python package installer, <code>pip</code>, should be installed. You can verify if <code>pip</code> is installed by running:</p> <pre><code>pip --version\n</code></pre> <p>If <code>pip</code> is not installed, you can install it by following the instructions here.</p> </li> </ul>"}, {"location": "getting-started/#installation", "title": "Installation", "text": "<p>Once you have the prerequisites, you can install TiLearn using pip. To install the latest version of TiLearn, run the following command:</p> <pre><code>pip install TiLearn\n</code></pre> <p>After the installation is complete, you can verify that TiLearn has been installed successfully by running:</p> <pre><code>pip show TiLearn\n</code></pre> <p>This command will display the package information, including the version number and installation path.</p>"}, {"location": "getting-started/#use-it", "title": "Use It", "text": "<p>After successfully installing TiLearn, you can begin using it in your Python scripts by importing it as follows</p> <pre><code>import tilearn\n</code></pre>"}, {"location": "getting-started/#understanding", "title": "Understanding", "text": ""}, {"location": "getting-started/#list-of-symbols-and-their-meanings", "title": "List of Symbols and Their Meanings", "text": "<p>\\(\\alpha \\: | \\: \\beta \\: | \\: \\gamma\\): Notation used to identify the type of problem. Here, \\(\\alpha\\) represents the number of machines that need scheduling. For the single machine case, it is denoted as \\(\\alpha = 1\\), i.e., \\(1 \\: | \\: \\beta \\: | \\: \\gamma\\). The \\(\\beta\\) field specifies any constraints of the problem, while \\(\\gamma\\) denotes the objective to be optimized.</p> <p>The details of the other element symbols are shown in the table below:</p> Symbol Description \\(J_{ij}\\) The \\(j\\)-th job processed on the \\(i\\)-th machine; in the single machine case, this is simply denoted as \\(J_j\\). \\(p_j\\) Processing time of the \\(j\\)-th job, which is the time from the start to the completion of the job. \\(d_j\\) Due date of the \\(j\\)-th job. \\(C_j\\) Completion time of the \\(j\\)-th job. \\(C_{\\max}\\) The maximum completion time (makespan) of all jobs, calculated as \\(C_{\\max} = \\underset{1 \\leq j \\leq n}{\\max} C_j\\). \\(S_j\\) Starting time of the \\(j\\)-th job, defined as \\(S_j = \\max (C_{j-1}, r_j)\\). \\(r_j\\) Release time of the \\(j\\)-th job. If \\(r_j \\neq 0\\), the job cannot start before time \\(r_j\\) (\\(S_j \\geq r_j\\)). If \\(r_j = 0\\), the job can start at any time. \\(W_j\\) Waiting time of the \\(j\\)-th job, which is the time from when the job is ready to when it starts, defined as \\(W_j = S_j - r_j = C_j - p_j - r_j\\). \\(F_j\\) Flow time of the \\(j\\)-th job, which is the time from when the job is ready to when it completes, defined as \\(F_j = C_j - r_j = W_j + p_j\\). \\(w_j\\) The weight of job \\(j\\), i.e., the priority level assigned to job \\(j\\). \\(L_j\\) The lateness of job \\(j\\), defined as the amount of time from \\(d_j\\) to \\(C_j\\), calculated by the formula \\(L_j = C_j - d_j\\). If \\(L_j &lt; 0\\), the job is completed earlier than its deadline, while if \\(L_j &gt; 0\\), the job is completed later than its deadline. \\(T_j\\) The tardiness of job \\(j\\), which is a measure of how late job \\(j\\) is defined through \\(L_j\\). If \\(L_j \\leq 0\\), then \\(T_j = 0\\); otherwise, if \\(L_j &gt; 0\\), \\(T_j = L_j\\), or \\(T_j = \\max(L_j, 0)\\). \\(E_j\\) The earliness of job \\(j\\), which is a measure of how early job \\(j\\) is defined through \\(L_j\\). If \\(L_j \\geq 0\\), then \\(E_j = 0\\); otherwise, if \\(L_j &lt; 0\\), \\(E_j = L_j\\), or \\(E_j = \\max(\\mid L_j \\mid, 0)\\). \\(prec\\) A problem with precedence constraints. If \\(prec\\) appears in the problem class \\(\\beta\\), it means that some jobs must be completed before other jobs can start, also known as predecessor and successor jobs. If each job in the problem has at most one predecessor and one successor, the problem forms a chain. If each job has at most one successor, the problem forms an in-tree. Conversely, if each job has at most one predecessor, the problem forms an out-tree. If \\(prec\\) does not appear in the problem class \\(\\beta\\), the jobs can be scheduled freely. \\(prmp\\) A problem with preemption, usually used when \\(r_j \\neq 0\\). If \\(prmp\\) appears in the problem class \\(\\beta\\), it means that jobs can be interrupted at any point and resumed later to achieve the objective of the problem. Conversely, if \\(prmp\\) does not appear in the problem class \\(\\beta\\), jobs cannot be interrupted."}, {"location": "getting-started/#scheduling-problem-types", "title": "Scheduling Problem Types", "text": "<p>This Python package solves different types of scheduling problems commonly encountered in operations research and optimization.</p> <p>Each problem type focuses on various objectives, such as minimizing the maximum lateness of jobs or the total weighted completion time. The problems are categorized based on job constraints, such as independence, precedence requirements, and release times, providing a comprehensive framework for effectively managing and optimizing job schedules.</p> <p>For single machine scheduling, we have a list of types shown below:</p> <ul> <li>The Maximum Lateness \\(\\big(L_{\\max}\\big)\\)<ul> <li>Independence jobs \\(\\big(1 \\: | \\:  \\: | \\: L_{\\max}\\big)\\)</li> <li>Release jobs \\(\\big(1 \\: | \\: r_j \\: | \\: L_{\\max}\\big)\\)</li> </ul> </li> <li>The Total (Weighted) Completion Time \\(\\big(\\sum w_j C_j\\big)\\)<ul> <li>Independence jobs \\(\\big(1 \\: | \\:  \\: | \\: \\sum w_j C_j\\big)\\)</li> <li>Sequence jobs \\(\\big(1 \\: | \\: prec \\: | \\: \\sum w_j C_j\\big)\\)</li> <li>Release jobs \\(\\big(1 \\: | \\: r_j \\: | \\: \\sum w_j C_j\\big)\\)</li> </ul> </li> </ul> <p>For a more in-depth understanding of how each type of scheduling problem works, check out the user guide.</p>"}, {"location": "getting-started/#references", "title": "References", "text": "<p>[1] Le Minh Huy. Single Machine Scheduling.</p> <p>[2] Michael Pinedo. Scheduling: Theory, Algorithms, And Systems. 01 2008.</p> <p>[3] M.L. Pinedo. Planning and Scheduling in Manufacturing and Services. Springer series in operations research. Springer New York, 2009.</p> <p>[4] PMI, editor. A Guide to the Project Management Body of Knowledge (PMBOK Guide). Project Management Institute, Newtown Square, PA, 5th edition, 2013.</p> <p>[5] Krzysztof Postek, Alessandro Zocca, Joaquim Gromicho, and Jeffrey Kantor. Hands-On Mathematical Optimization with AMPL in Python. Online, 2024.</p>"}, {"location": "news/", "title": "News on Version Updates", "text": "<p>This page only posts the most important information for the upgrade that I think needs attention.</p> <p>Minor upgrades are not updated here to maintain minimalism.</p>"}, {"location": "news/#tilearn-0010-released", "title": "TiLearn 0.0.10 released", "text": "<p>Released: Aug 25, 2024 </p> <p>TiLearn 0.0.10 is the foundational version, designed to provide an easier way to organize your time and life. One of the most notable highlights of this release is:</p> <ul> <li>The creation of the function <code>tilearn.show_mytime()</code>.</li> </ul>"}, {"location": "user-guide/", "title": "User Guide Overview", "text": "<p>When dealing with single machine scheduling, there are various types of scheduling problems to consider.</p> <p>The list of these types is shown below, each addressing different constraints and objectives to optimize the scheduling process.</p>"}, {"location": "user-guide/#the-maximum-lateness-bigl_maxbig", "title": "The Maximum Lateness \\(\\big(L_{\\max}\\big)\\)", "text": "<p>Basically, it prioritizes tasks with the earliest due dates, ensuring they are completed first to reduce the chances of delays and minimize \\(L_{\\max}\\).</p> <p>We have two specific subproblems related. Each subproblem focuses on different constraints and objectives for optimizing scheduling on a single machine, which are outlined below:</p> <ul> <li>EDD algorithm</li> <li>Independence jobs</li> <li>Release jobs</li> </ul>"}, {"location": "user-guide/#the-total-weighted-completion-time-bigsum-w_j-c_jbig", "title": "The Total (Weighted) Completion Time \\(\\big(\\sum w_j C_j\\big)\\)", "text": "<p>This problem aim to minimize the average waiting time \\(\\overline{W}\\) and the total completion time \\(\\sum C_j\\) or \\(\\sum w_j C_j\\) (if weights \\(w_j\\) are present) by prioritizing tasks with the shortest processing times.</p> <p>We have three specific subproblems related. Each subproblem also focuses on different constraints and objectives for optimizing scheduling on a single machine, which are outlined below:</p> <ul> <li>SWP/WSPT algorithm</li> <li>Independence jobs (<code>show_mytime</code>)</li> <li>Sequence jobs</li> <li>Release jobs</li> </ul>"}, {"location": "user-guide/#references", "title": "References", "text": "<p>[1] Le Minh Huy. Single Machine Scheduling.</p> <p>[2] Michael Pinedo. Scheduling: Theory, Algorithms, And Systems. 01 2008.</p> <p>[3] M.L. Pinedo. Planning and Scheduling in Manufacturing and Services. Springer series in operations research. Springer New York, 2009.</p> <p>[4] PMI, editor. A Guide to the Project Management Body of Knowledge (PMBOK Guide). Project Management Institute, Newtown Square, PA, 5th edition, 2013.</p> <p>[5] Krzysztof Postek, Alessandro Zocca, Joaquim Gromicho, and Jeffrey Kantor. Hands-On Mathematical Optimization with AMPL in Python. Online, 2024.</p>"}, {"location": "user-guide/single-machine/completion/wspt/", "title": "The Total Weighted Completion Time \\(\\big(\\sum w_j C_j\\big)\\)", "text": ""}, {"location": "user-guide/single-machine/completion/wspt/#wspt-algorithm", "title": "WSPT Algorithm", "text": "<p>Note</p> <p>The problem \\(1\\| \\sum C_j\\) is a special case of \\(1\\| \\sum w_j C_j\\) with weights \\(w_j = 1\\). Thus, SPT is the same as WSPT when \\(w_j = 1\\), allowing us to focus on \\(1\\| \\sum w_j C_j\\).</p>"}, {"location": "user-guide/single-machine/completion/wspt/#independence-jobs-show_mytime", "title": "Independence jobs (<code>show_mytime</code>)", "text": "<p>Info</p> <p>The symbol for the problem is \\(1 \\: | \\:  \\: | \\: \\sum w_j C_j\\)</p>"}, {"location": "user-guide/single-machine/completion/wspt/#sequence-jobs", "title": "Sequence jobs", "text": "<p>Info</p> <p>The symbol for the problem is \\(1 \\: | \\: prec \\: | \\: \\sum w_j C_j\\)</p>"}, {"location": "user-guide/single-machine/completion/wspt/#release-jobs", "title": "Release jobs", "text": "<p>Info</p> <p>The symbol for the problem is \\(1 \\: | \\: r_j \\: | \\: \\sum w_j C_j\\)</p>"}, {"location": "user-guide/single-machine/lateness/edd/", "title": "Minimization of Maximum Lateness \\((L_{\\max})\\)", "text": "<p>As mentioned earlier, the goal of Minimization of Maximum Lateness \\((L_{\\max})\\) problem prioritizes tasks with the earliest due dates, ensuring they are completed first to reduce the chances of delays and minimize \\(L_{\\max}\\).</p>"}, {"location": "user-guide/single-machine/lateness/edd/#edd-algorithm", "title": "EDD Algorithm", "text": "<p>The EDD (Earliest Due Date) algorithm is a popular and effective single-machine scheduling technique aimed at minimizing maximum lateness \\(L_{\\max}\\).</p>"}, {"location": "user-guide/single-machine/lateness/edd/#independence-jobs", "title": "Independence jobs", "text": "<p>Info</p> <p>The symbol for the problem is \\(1 \\: | \\:  \\: | \\: L_{\\max}\\).</p>"}, {"location": "user-guide/single-machine/lateness/edd/#release-jobs", "title": "Release jobs", "text": "<p>Info</p> <p>The symbol for the problem is \\(1 \\: | \\: r_j \\: | \\: L_{\\max}\\).</p> <p>In development process...</p>"}]}